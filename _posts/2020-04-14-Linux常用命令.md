---
title: Linux常用命令
date: 2020-04-14 16:05:00 +0800
categories: [Linux]
tags: [linux]    # TAG names should always be lowercase
---

## 0 开始

### 0.1 显示当前用户名 *whoami*

|选项|功能|
|:-:|:-:|
|--help|显示帮助信息|
|--version|显示版本信息|

example:  
`whoami`

### 0.2 显示当前工作目录 *pwd*

example:  
`pwd`当前完整工作目录

### 0.3 回显字符串 *echo*

|选项|功能|
|:-:|:-:|
|-n|不显示换行符|
|-e|启用反斜杠转义功能|
|-E|禁用反斜杠转义功能（默认）|
|--help|显示帮助信息|
|--version|显示版本信息|

example:  
`echo "Hello World."`  
`echo -n "Hello World."` 输出字符串后不换行  
`echo -e "Hello World.\n\n"` 输出转义字符

### 0.4 简易文本编辑器 *nano*

example:  
`nano`

### 0.5 查看帮助文档 *man*

|快捷键|功能|
|:-:|:-:|
|上/下箭头|向上/下滚动一行|
|<kbd>Space</kbd>/<kbd>Page Down</kbd>|向下翻一页|
|<kbd>Page Up</kbd>|向上翻一页|
|<kbd>Home</kbd>/<kbd>End</kbd>|第一页/最后一页|
|/字符串|向下查找字符串内容|
|?字符串|向上查找字符串内容|
|<kbd>n</kbd>|跳转至下一匹配处|
|<kbd>N</kbd>|跳转至上一匹配处|
|<kbd>q</kbd>|退出|

example:  
`man [命令]`

### 0.6 关机 *shutdown*

example:  
`shutdown -h [时间] [字符串]` 关机  
`shutdown -r [时间] [字符串]` 重启  
`shutdown -c` 取消关机命令  
时间：分钟数、00:00、now  
字符串：该字符串将发送给所有连接到主机的终端上  
`reboot` = `shutdown -r now`  
`halt` = `shutdown -h now`  
`poweroff` = `halt` + 切断电源指令

### 0.7 输出控制命令（与管道搭配使用）

#### 0.7.1 切片 *cut*

example:  
`cut -c1,2` 输出第1、2列字符  
`cut -f1 -d":"` -d后紧跟分隔符，-f后紧跟切割的字段序列号

#### 0.7.2 筛选 *grep*

example:  
`grep [关键字] [目标文件]` 查找目标文件中带有关键字的行

#### 0.7.3 排序 *sort*

example:  
`sort -k[关键字字段序号] [要排序的文本文件]` 对文本中的内容按规定字段进行排序

### 0.8 小技巧

1. 历史命令：用上下箭头查看历史命令
2. 命令补齐：
   * 单击Tab：补全剩余字符
   * 双击Tab：显示全部匹配的命令（单击Tab无反应）
3. 取消命令：Ctrl+C
4. 写入到/dev/null的文件内容都被丢弃
5. 替换特定字符：`tr [准备要替换的字符] [要替换成的字符]`

### 0.9 统计 *wc*

example:  
`wc [文件]` 统计行数、单词数、字节数  
`wc -l [文件]` 统计行数

## 1 管理文件

### 1.1 切换工作目录 *cd*

example:  
`cd /文件夹` 切换到指定文件夹  
`cd ./dir01` "."表示当前目录（切换到当前目录中的dir01文件夹中）  
`cd ../dir02` ".."表示前一个目录（切换到上层目录中的dir02文件夹中）  
`cd -` "-"表示前一个目录（切换到上层目录）  
`cd ~` "~"表示当前用户家目录（切换到当前用户家目录中）  
`cd ~[用户名]` 切换到指定用户的家目录中  

### 1.2 创建目录 *mkdir*

|选项|功能|
|:-:|:-:|
|-m --mode|设置权限模式（类似chmod命令）|
|-p|需要时创建目标目录的上层目录，但即使这些目录已存在也不作错误处理|

example:  
`mkdir [目录名]` 在当前目录下创建目录  
`mkdir -p /tmp/dirlevel01/dirlevel02` 创建嵌套目录

### 1.3 删除目录 *rmdir*

example:  
`rmdir [目录名]` 删除目录（只能删除空目录）

### 1.4 文件属性说明

|文件类型||
|:-:|:-:|
|-|常规文件|
|d|目录文件|
|\||符号链接文件|
|c|字符特殊设备文件|
|b|模块特殊设备文件|
|p|FIFO管道文件|
|s|套接字文件|
文件访问权限由九位二进制数组成，前三位表示拥有者权限，中间三位表示组用户权限，后三位表示其他人权限。第一位表示读权限，第二位表示写权限，第三位表示执行权限。

### 1.5 列出当前目录所有文件的信息 *ls*

|选项|功能|
|:-:|:-:|
|-a|列出所有文件|
|-A|列出除以.或..开头的所有文件|
|-c|按ctime（文件属性或者内容最后更改的时间）排序；同-lt一起使用：根据ctime排序并显示ctime；同-l一起使用：显示ctime但根据名称排序。|
|-d|当遇到目录时列出目录本身而非目录内的文件|
|-F|加上文件类型的指示符号（*/=@\|其中一个）|
|-h|与-l一起，以易于阅读的格式输出文件大小（例如1K、234M、2G等，默认情况下的单位是Byte）|
|-i|显示每个文件的inode号|
|-l|使用较长格式列出信息|
|-n|类似-l，但列出UID及GID号|
|-r|排序时保留顺序|
|-R|递归显示子目录|
|-S|根据文件大小排序|
|-t|根据mtime（文件内容最后修改时间）排序|
|-u|按照atime（文件最后访问时间）排序；同-lt一起使用：按照访问时间排序并显示；同-l一起使用：显示访问时间并按文件名排序。|

example:  
`ls [文件名]` 列出该文件  
`ls [目录名]` 列出目录中的文件  
`ls` 列出当前工作目录下的文件  
`ls -a` 列出所有文件（包括以.开头的隐藏文件）  
`ls -l` 列出文件并显示属性信息  
`ls -al` 包括上述两种功能  
`ls -i` 列出文件的INode-Number

#### 文件属性字段

|序号|样式|含义|
|:-:|:-:|:-:|
|1|-rw-rw-r--.|类型和权限|
|2|1|连接数|
|3|dev01|拥有者|
|4|dgroup|文件组|
|5|116|大小|
|6|9月27 12:42|被修改日期|
|7|helloworld.sh|文件名|

### 1.6 创建文件 *touch*

example:  
`touch [要创建的文件]`创建一个文件  
`touch [已经存在的文件]`修改该文件的时间戳

### 1.7 修改文件权限 *chmod*

|选项|功能|
|:-:|:-:|
|--reference=[参考文件]|使用指定参考文件的模式，而非指定权限值|
|-R，--recursive|以递归方式更改所有的文件及子目录|

example:  
`chmod [三位八进制数] [文件名]` 修改文件权限

### 1.8 修改文件的拥有者和从属用户组 *chown*

example:  
`chown [文件拥有者]:[用户组] [文件名]` 更改文件的拥有者和从属用户组

### 1.9 复制文件 *cp*

|选项|功能|
|:-:|:-:|
|-f|如果目标文件无法打开则将其移除并重试|
|-i|覆盖前询问（使-n选项失效）|
|-l|只创建硬链接文件而不复制文件|
|-n|不覆盖已存在的文件（使-i选项失效）|
|-p|复制时保留文件的访问权限，拥有者，文件组和时间戳|
|-R|递归复制目录及其子目录内的所有内容|
|-s|只创建符号链接而不复制文件|
|-u|只在源文件文件比目标文件新，或目标文件不存在时才进行复制命令|

example:  
`cp [要拷贝的文件名] [目录名]` 将目标文件拷贝到目标目录  
`cp /tmp/file01 ~` 将file01文件拷贝到家目录  
`cp /tmp/file01 ~/file01_bak` 将file01文件拷贝到家目录并重命名为file01_bak  
`cp /tmp/file02 /tmp/file03 /tmp/file04 ~` 将file02 03 04文件拷贝到家目录  
`cp -r /tmp/dir01 ~` 将dir01目录拷贝到家目录  
`\cp -f /tmp/file02 /tmp/file03 ~` 强制覆盖同名文件（不确定）  
`cp -p /tmp/sample.sh ~nbcc` 将sample.sh文件拷贝到nbcc家目录中，并且保留文件拥有者、用户组信息

### 1.10 删除文件 *rm*

|选项|功能|
|:-:|:-:|
|-f|强制删除，忽略不存在的文件，不提示确认|
|-i|在删除前需要确认（默认选项）|
|-R|递归删除目录及其内容|

example:  
`rm [要删除的文件/目录]`  
`rm ./file01` 删除一个文件  
`rm ./file02 ./file03 ./file04` 删除多个文件  
`rm -R ./dir01` 删除一个目录  
`rm -fR ./dir02` 不询问直接删除目录

### 1.11 移动/重命名文件 *mv*

|选项|功能|
|:-:|:-:|
|-f|覆盖前不询问|
|-i|覆盖前询问|
|-n|不覆盖已存在文件|
|-u|只在源文件文件比目标文件新，或目标文件不存在时才进行移动|

* mv没有-R选项，mv可以直接移动目录。
* 如果指定了-i、-f、-n中的多个，仅最后一个生效。  

example:  
`mv [文件/目录] [目录]` 移动文件  
`mv /tmp/file05 ~` 将05文件移动到家目录  
`mv /tmp/file06 /tmp/file07 /tmp/file08 ~` 将06 07 08文件移动到家目录中  
`mv /tmp/dir02 ~` 将02目录移动到家目录中  
`mv -f [] []` 强制覆盖所有同名文件  
`mv ./file08 ./file08_rename` 重命名

### 1.12 创建硬链接/符号链接 *ln*

|选项|功能|
|:-:|:-:|
|-d|创建指向目录的硬链接（只适用于根用户）|
|-f|强行覆盖任何已存在的目标文件|
|-i|覆盖文件前进行确认|
|-s|创建符号链接|

> * 文件的硬链接就可以理解为文件的一个别名，而符号链接则可以视为文件的一个快捷方式。
> * 删除一个符号链接不会影响到这个符号链接指向的目标文件或目录。
> * 反过来，删除、移动或者重命名某个符号链接所指向的目标文件或目录不会导致这个符号链接被删除，只会让这个符号链接“断裂”。
> * 如果一个文件有多个硬链接，仅在其最后一个硬链接被删除且硬链接数为0时文件才会被真正从文件系统中删除。
> * 由于inode仅在一个文件系统分区内是唯一的，因此硬链接不能够跨越文件系统。
> * 符号链接没有上面的限制，具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。

example:  
`ln [选项] [目标] [链接名]` 创建指定名称且指向指定目标链接  
`ln [选项] [目标]` 在当前目录创建指向目标位置的链接  
`ln [选项] [目标] [目录]` 在指定目录中创建指向指定目标的链接  
> 默认创建硬链接，当使用-s时创建符号链接。当创建硬链接时每个指定的目标都必须存在。符号链接可以指向任意的位置（包括不存在的位置）。

`ln -s [链接指向的文件] [链接名]` 创建符号链接  
`ln [链接指向的文件] [链接名]` 创建硬链接
> 注：不要为目录创建硬链接；不能跨硬盘分区创建硬链接。

### 1.13 文件归档 *tar*

|选项|功能|
|:-:|:-:|
|-c|创建一个新的归档文件|
|-r|向归档文件末尾追加文件|
|-u|更新归档文件|
|-x|从归档文件中解出文件|
|-t|列出归档文件中的文件|
|--delete|从归档文件中删除一个文件|
|-A|合并两个归档文件|
|-C|指定一个解档目录|
|-f|指定一个归档文件/设备进行操作|
|-z|调用gzip来压缩/解压缩文件|

example:
`tar -cf [打包文件名] [要打包的文件/文件列表]` 打包文件  
`tar -tf [打包文件]` 列出打包文件中所有文件名  
`tar -tf [打包文件] --delete [打包文件中的文件名]` 删除打包文件中的指定文件  
`tar -f [合并到该文件] -A [合并的目标文件]` 将后者合并到前者  
`tar -f [打包文件] -r [目标文件]` 将目标文件合并到打包文件中  
`tar -xf [要解包的文件] -C [目标目录]` 将打包文件解包到目标目录中（不加-C默认解包到当前目录）  
`tar -czf [文件名.tar.gz] [文件/文件列表]` 打包并压缩文件  
`tar -xzf [文件名.tar.gz]` 解压缩并解包

> * 归档文件后缀.tar
> * -f选项后必须紧跟归档文件名
> * 文件归档不会对文件进行压缩

### 1.14 压缩文件 *gzip*

|选项|功能|
|:-:|:-:|
|-c|将输出写到标准输出上，并保留原有文件|
|-d|将压缩文件解压|
|-r|递归式压缩/解压缩指定目录中的所有文件|
|-num|用指定的数字num调整压缩的速度和压缩比|
|-v|对每一个压缩和解压的文件显示文件名和压缩比|
|-t|测试，检查压缩文件是否完整|

example:  
`gzip [要压缩的文件/目录]` 压缩文件  
`gzip -数字1-9 [要压缩的文件/目录]` 按压缩比压缩文件（数字越大文件越小，默认为6）  
`gzip -d [要解压的文件]` 解压文件

> * gzip只能压缩单个文件，因此先用tar打包，再用gzip压缩
> * gzip在压缩文件过程中，会自动为文件添加一个.gz的后缀，并且将原文件删除
> * 如果要保留原文件，就必须使用-c选项和Shell的输出重定向机制

### 1.15 查找文件 *find*

|选项|功能|
|:-:|:-:|
|-print|将查找到的文件输出到标准输出|
|-exec command {} \;|将查到的文件执行command操作|
|-fprint <filename>|将查找到的文件输出到指定文件|
|-ok|和-exec相同，只是在操作前要询问用户|
|-name <filename>|查找名为filename的文件|
|-iname|与-name相同，只是忽略大小写|
|-perm|按执行权限来查找|
|-user <username>|按文件拥有者查找|
|-group <groupname>|按组查找|
|-amin <-n\|+n>|按文件**访问**时间查找文件，-n指n分钟之内，+n指n分钟以前|
|-atime <-n\|+n>|按文件**访问**时间查找文件，-n指n天之内，+n指n天以前|
|-cmin <-n\|+n>|按文件**创建**时间查找文件，-n指n分钟之内，+n指n分钟以前|
|-ctime <-n\|+n>|按文件**创建**时间查找文件，-n指n天之内，+n指n天以前|
|-mmin <-n\|+n>|按文件**更改**时间查找文件，-n指n分钟之内，+n指n分钟以前|
|-mtime <-n\|+n>|按文件**更改**时间查找文件，-n指n天之内，+n指n天以前|
|-empty|空白文件、空白文件夹、没有子目录的文件夹|
|-newer <f1 !f2>|查找更改时间比f1新但比f2旧的文件|
|-type <b\|d\|c\|p\|l\|f>|查找块设备/目录/字符设备/管道/符号链接/普通文件|
|-prune|忽略某个目录|
|-size <+n\|-n>|根据文件大小查找文件，+n表示超过n大小的文件，-n表示小于n大小的文件|
|-size <n[cwbkMG]>|n表示文件大小的数值，b表示512字节的块，c表示字节，k表示千字节，M表示兆字节，G表示吉字节|
|-type <[bcdpfls]>|b表示块设备文件，c表示字符设备文件，d表示目录，p表示命名管道文件，f表示普通文件，l表示符号链接文件，s表示socket文件|

example:  
`find [查找范围（省略则认为在当前工作目录查找）] [查找条件] [动作]`  
`find / -name passwd` 在根目录中查找有passwd的文件（passwd必须是准确名称而不是关键字）  
`find /bin -type l` 根据文件属性（l）查找  
`find /tmp -mtime -3 -ls` 查找三天之内内容发生改变的文件  
`find /tmp -mtime +7 -ls` 查找七天前内容发生改变的文件  
`find /tmp -mtime 4 -ls` 查找四天前当天内容发生改变的文件

> -mmin：单位从天改为分钟  
> -atime -amin：文件被读取/执行时间  
> -ctime -cmin：文件属性修改时间  
> -mtime -mmin：文件修改时间  
> +n：n天之前  
> n：前第n天  
> -n：n天之内  

`find /tmp -size -3k -ls` 查找比3k字节小的文件  
`find /tmp -size +100c -ls` 查找比100字节大的文件  
`find /tmp -size 10M -ls` 查找大小正好是10M字节的文件

> c：字节  
> k：千字节  
> M：兆字节  
> G：吉字节

`find /tmp -user root -ls` 查找拥有者是root的文件  
`find /tmp -uid 500 -ls` 查找拥有者uid是500的文件  
`find /tmp -group stu -ls` 查找从属于stu用户组的文件  
`find /tmp -gid 0 -ls` 查找从属于gid为0的用户组的文件  
`find /tmp -perm 754 -ls` 查找754权限的文件  
`find /tmp \( -size +1k -a -size -10M -a -mmin -30 -a -type f \) -ls`

> -a:与  
> -o:或  
> !：非

`find /tmp \( -size +1k -a -size -10M -a -mmin -30 -a -type f \) -exec rm -rf {} \;`将find找到的文件删除（`rm -rf`：命令；`{}`：find找到的文件；`\;`：动作结束）  
`find ~ \( -mmin -10 -a -type d \) -exec tar -cf {}.tar {} \;` 在家目录下查找在十分钟内被创建或者被修改过的目录文件，并且将它们打包成与目录同名，后缀为.tar的打包文件

> * 用-ok替换-exec：在执行命令前逐个提示，通过用户确认
> * 使用多个条件时，这些条件要用圆括号括起来，左右圆括号还要使用反斜杠\进行转义，以防止shell的解释

### 1.16 查找文件 *locate*

example:  
`locate [查找的路径] [文件名的关键字]`查找文件  
所有文件名存在/var/lib/mlocate数据库中  
`updatedb`更新数据库

### 1.17 通配符

|字符|含义|实例|
|:-:|:-:|:-:|
|*|任意长度字符串|a*b可以匹配ab, a012b, aabcb|
|?|任意单个字符|a?b匹配a与b之间只有一个字符|
|[list]|匹配list中的任意单一字符|a[xyz]b只能匹配axb, ayb, azb|
|[!list]|匹配除list中的任意单一字符|a[!0-9]b匹配a与b之间有且只有一个字符但不是数字|
|[c1-c2]|匹配c1-c2字符序列中的任意单一字符|a[0-9]b匹配a0b, a1b, ..., a9b|
|[c1,c2,...,cn]|匹配中括号之间字符列表中的任意一个单一字符||
|{string1,string2,...,stringn}|匹配N个字符串中的某一个字符串|a{abc,xyz,123}b只能匹配aabcb, axyzb, a123b|

> * !：与[],{}联用，表示取反
> * *和？字符与它们自身匹配。如果在文件名中使用这些字符，那么需要注意适当的引用或转义
> * 两个字符之间的-表示一个范围，包括这两个字符和排序序列中介于这两个字符之间的所有字符。例如[0-9a-fA-F]表示任何大写或小写十六进制数。
> * ！在shell中是有特殊含义的，因此需要小心地对它进行适当的转义。
> * 文件通配符被单独应用到路径名的每个组成中，但我们无法匹配/。

### 1.18 查看文件

#### 1.18.1 将文件内容输出到标准输出 *cat*

|选项|功能|
|:-:|:-:|
|-b|对非空输出行编号|
|-E|在每行的末尾添加$号，便于确认每一行。因为有些行内容太长了，在显示时会在显示器上以多行显示|
|-n|对输出的所有行编号|
|-s|将相连的多个空行用一个空行代替|
|-T|将Tab字符显示为^\||

> 如果没有指定文件，或者文件为“-”，则从标准输入读取

example:  
`cat /etc/passwd` 查看用户配置文件（适合查看小文本文件）

#### 1.18.2 对文件或其他输出进行分页显示 *less*

|选项|功能|
|:-:|:-:|
|-n|对输出的所有行编号|
|-M|输出打开的文件名，当前显示的行数，总行数和光标当前所处文档位置|
|-s|将相连的多个空行用一个空行代替|
|-S|截断过长的行而不换行显示|

example:  
`less /var/log/messages`查看文件

|less中的命令|作用|
|:-:|:-:|
|上下箭头|翻行|
|<kbd>PageUp</kbd>/<kbd>PageDown</kbd>|上下翻页|
|/关键字|查找关键字|
|n|跳转到下一关键字|
|N|跳转到上一关键字|
|q|退出less命令|

#### 1.18.3 将每个指定文件的前10行显示到标准输出 *head*

|选项|功能|
|:-:|:-:|
|-c K|显示每个文件的前K字节内容；如果附加“-”参数，则除了每个文件的最后K字节数据外显示剩余全部内容|
|-n K|显示文件的前K行内容|

example:  
`head -n 20 [文件名]` 显示文件前20行（没有n选项则默认显示前10行）

> 如果指定了多于一个文件，在每一段输出前会给出文件名作为文件头。如果不指定文件，或文件为“-”，则从标准输入读取数据。

#### 1.18.4 显示每个指定文件的最后10行到标准输出 *tail*

|选项|功能|
|:-:|:-:|
|-c K|输出最后K字节；另外，使用-c +K从每个文件第K字节输出|
|-n K|显示文件的最后K行内容|

example: tail与head用法一样，用于显示文件后几行

> 若指定了多于一个文件，程序会在每段输出的开始添加相应文件名作为头。如果不指定文件或文件为“-”，则从标准输入读取数据。

## 2 重定向与管道

### 2.1 输入输出流

* 标准输入流（stdin），向命令提供输入，文件描述符是0。
* 标准输出流（stdout），显示来自命令的输出，文件描述符是1。
* 标准错误输出流（stderr），显示来自命令的错误输出，文件描述符是2。

### 2.2 输出重定向

* `n>`：表示将来自文件描述符n的输出重定向到文件。必须对这个文件有写权限。如果文件不存在，就创建它。如果它存在，**将覆盖原有文件内容**。
* `n>>`：也表示将来自文件描述符n的输出重定向到文件。同样，必须对这个文件有写权限。如果文件不存在，就创建它。如果它存在，**输出就附加到现有文件后面**。
* 有时候希望将标准输出和标准错误重定向到同一个文件中。可以使用`&>`或`&>>`将标准输出和标准错误重定向到同一个位置。
* 有时候希望完全忽略标准输出或标准错误。为此，可以把适当的流重定向到/dev/null中。

example:  
`ls -l /tmp/example/ 1> ./stdout.txt` 将ls命令的结果输出到txt文件中（如果目标文件不存在，则文件将被创建；如果目标文件已经存在，则内容将被覆盖）  
`ls -l /tmp/example/ 1>> ./stdout.txt` 如果文件存在，命令产生的内容会添加到原来内容的后面  
`ls -l /tmp/example/file01 /tmp/example/file04 1>stdout.txt 2>stderr.txt` 将标准输出和错误输出同时重定向  
`ls -l /tmp/example/file01 /tmp/example/file04 &> std.txt` 将标准输出和错误输出同时重定向

### 2.3 输入重定向

* 可以使用<操作符将stdin重定向为来自文件。
* 使用<<以及一个单词（比如 EOF），这个单词作为输入结束的标志。

example:  
`tr ' ' '\t' <./fruit.txt` 将txt文件中的空格替换为制表符  
`sort -k2 <<EOF` 将输入文本中到EOF为止的字段按第二个字符进行排序

### 2.4 管道

* 在两个命令之间使用|（管道）操作符就是将第一个命令的stdout定向到第二个命令的stdin，可以通过添加更多的命令和更多的管道操作符来构造长管道来完成更复杂的任务。
* 管道命令只处理前一个命令正确输出，**不处理错误输出**。
* 管道命令右边命令，必须能够接收标准输入流命令才行。
* 常用来作为接收数据管道命令有：sed, awk, cut, head, tail, top, less, more, wc, join, sort, split等等，都是些文本处理命令。

example:  
`ls -al /etc |less` 逐行查看ls的输出  
`ls -al /etc |grep 'ssh'` 在ls输出中查找带ssh字段的行  
`cat ~/install.log | cut -c1,2` 输出log文件的前两列  
`cat /etc/passwd | cut -f1 -d":"` 切割passwd的第一个字段，该字段用冒号隔开  
`ls -al ~|cut -c1|grep "d"|wc -l` 统计家目录中目录文件的个数

## 3 Vim

`vim --version`查看vi版本（微型、小型、普通、大型、巨型）

|快捷键|功能|
|:-:|:-:|
|i|输入模式|
|esc|返回一般模式|
|h j k l|左下上右|
|x|删除|
|[数字]x|删除不包括当前字符的n个字符|
|dd|删除一整行|
|[数字]dd|删除不包括当前行的向下n行|
|J|删除当前行换行符|
|u|撤销|
|Ctrl+r|重做|
|:wq|退出，保存文件（后面加文件名可以以该文件名保存）|
|:q!|退出，放弃所有修改|
|gg|移动到文件首行|
|G|移动到文件末行|
|[数字]G|移动到某行行首|
|0|移动到当前行首|
|$|移动到当前行尾|
|[数字]$|下移某行，并定位到行尾|
|y|复制选定内容|
|yy|复制当前行|
|[数字]yy|复制不包括当前行的向下n行|
|p|在光标的下一行上粘贴|
|w|保存|

> 环境设置参数  
>
> * `:set [设置参数]`
> * `:set no[设置参数]`
> * `:set all` 查阅所有设置参数

example:

1. 设定行号

   ```text
   :set nu
   :set nonu
   ```

2. 数字+移动命令  
   移动到第58行行首：`gg 57j`或`58G`  
   向右移动30个字符：`30l`  
   移动到第8行行尾：`8G $`  
   向左移动三列：`3l`  
   移动到文件末行：`G`

3. 移动到第一行行首，并且向下搜寻"man"字符串

   ```text
   gg
   /man
   n：下一个
   N：上一个
   ```

4. 将50到100行之间的"man"替换为"MAN"

   ```text
   数字,数字s/查找字符串/替换字符串/gc（c：询问，没有c则不询问）
   50,100s/man/MAX/gc
   1,$s/man/MAN/g在整个文件查找并替换
   ```

5. 复制51到60行内容，并粘贴到最后一行之后

   ```text
   50G
   10yy
   G
   p
   ```

6. 删除11到30行，到第29行行首，删除15个字符
7. 撤销前面的所有修改  
   `:e!`
8. 将这个文件另存为man.config.bak  
   `:w man.config.bak`
9. 在最后一行后插入turtle.txt文件内容并保存  
   `:r ./turtle.txt`（r：将文件内容追加到光标所在行的后面）
10. 同时打开man.config.bak和man.config  
   `vim [文件名] [文件名] [文件名]`打开多个文件  
   `:n`下一个文件  
   `:N`上一个文件
11. 将man.config.bak中插入的turtle.txt文件内容的第1列到第10列复制到man.config中  
   `Ctrl+v`进入可视模式进行选择区域
12. 存储两个文件后退出vim  

参考文档：<https://www.runoob.com/linux/linux-vim.html> <https://www.vim.org/docs.php>

## 4 管理用户

* UID是确认用户权限的标识，用户登录系统所处的角色是通过UID来实现的，而非用户名，因此，每个用户的UID必须是唯一的。
* CentOS系统会把前499个UID预留出来，给系统虚拟用户占用，虚拟用户一般是系统安装时就有的，是为了完成系统任务所必须的用户，但虚拟用户是不能登录系统的，比如ftp、nobody、adm、rpm、bin、shutdown等。
* 添加普通用户时的UID从500开始的，GID也是从500开始，至于其它系统，有的系统可能会把前999的UID和GID预留出来；以各个系统中/etc/login.defs文件中的UID_MIN的最小值为准；CentOS系统login.defs的UID_MIN是500，而UID_MAX值为60000，也就是说我们通过`user add`添加的普通用户的UID的值一般都是在500到60000之间。

### 4.1 查看用户 *id* / *finger*

example:  
`id [用户名]` 显示用户UID GID  
`finger [用户名]` 查看用户信息、家目录、上次登录、shell类型

### 4.2 临时切换用户身份 *su*

|选项|功能|
|:-:|:-:|
|-或-l|在切换用户的同时切换到相应用户的登录环境，包括家目录，SHELL定义等|

example:  
`su - root`切换至根用户（-：切换运行环境）

* -l选项可以简写为-，也即`su -l root`等价于`su - root`
* 如果su不带[用户名]参数，默认为切换到root用户，也即`su -`等价于`su - root`
* 如果root向普通用户切换不需要密码，而普通用户切换到其它任何用户都需要密码验证

### 4.3 创建用户 *useradd*

|选项|功能|
|:-:|:-:|
|-c|后面接一个字符串，是对本用户的一些描述，也可以视为用户全名|
|-u|后面接一个数字，指定一个特定的UID给这个用户，该值必须唯一，不可相同，数值不可为负|
|-g|后面接的用户组名就是我们上面提到的初始用户组|
|-G|后面接的用户组名则是这个用户还要加入的其余用户组|
|-M|不建立用户家目录（虚拟用户默认值）|
|-m|建立用户家目录（普通用户默认值）|
|-d|指定某个目录成为家目录，而不使用默认值|
|-r|建立一个系统虚拟用户|
|-e|后面接一个日期，格式为『YYYY-MM-DD』，指定这个用户失效的日期|
|-f|指定密码是否会失效。0为立刻失效，-1为永远不会失效（密码只会过期而强制在登入时重新指定而已）|

example:  
`useradd [用户名]` 创建新用户  
`useradd -c [用户备注] -u [UID] -d [家目录] -g [主用户组名] -G [其他用户组名] -s [使用的shell]`

### 4.4 创建/修改用户密码 *passwd*

example:  
`passwd [用户名]` 为用户名修改密码

### 4.5 修改用户设置 *usermod*

|选项|功能|
|:-:|:-:|
|-c/-d/-e/-f/-g/-G/-s/-u|与useradd同名选项意义类同|
|-l|后面跟用户名，修改用户名称|
|-L|暂时将用户锁住，让他无法登录|
|-U|解锁用户|

example:  
`usermod -c [用户备注] -d [家目录] -g [主用户组] -G [从属用户组] -s [使用shell] [用户名]` 修改用户名的用户备注等  
`usermod -u [UID] -l [目标用户名] [原用户名]` 修改原用户名的UID和用户名

* usermod不允许改变正在线上的用户名和用户UID。当usermod用来改变用户名和 UID，必须确认这名用户没在系统上执行任何程序。

### 4.6 删除用户 *userdel*

|选项|功能|
|:-:|:-:|
|-r|表示在删除用户的同时，一并把用户的家目录及本地邮件存储的目录或文件也一同删除|
example:  
`userdel [用户名]` 删除用户  
`userdel -r [用户名]` 删除用户及其家目录

* 不允许删除正在线上的用户。

### 4.7 以管理员身份运行命令 *sudo*

1. 用 `vim /etc/sudoers` 打开/etc/sudoers文件
2. 找到 `root ALL=(ALL) ALL`
   * 用户 可登录的主机=(可切换的用户身份列表) 可使用的命令列表
   * 表示 root 用户可以在任何地方（远程终端）登录，并且以任意用户身份执行任何命令
3. 添加一行 `intern01 ALL=(ALL) ALL`
   * 表示intern01用户可以在任何地方（远程终端）登录，以任意用户身份执行任何命令
4. 只能使用有限权利 `intern01 localhost=(root) /sbin/shutdown -h 5`
   * 表示intern01用户可以在本地登录，以root用户身份执行 `/sbin/shutdown -h 5` 这个命令，命令要以绝对路径的方式指定
5. 按用户组指定 `%group_p 192.168.56.130=(root) /sbin/shutdown -h 5`
   * 表示从属于 group_p 用户组的用户可以在 192.168.56.130 主机上登录，以 root 用户身份执行 `/sbin/shutdown -h 5` 这个命令
6. 免除输入密码的步骤 `%group_p 192.168.56.130=(root) NOPASSWD:/sbin/shutdown -h 5`
   * 表示从属于group_p用户组的用户可以在 192.168.56.130 主机上登录，以 root 用户身份执行 `/sbin/shutdown -h 5` 这个命令，并且无需输入用户密码

example:  
`sudo -u root passwd intern02` 以 root 身份执行 passwd 命令，可以省略 -u 选项，命令是默认转换为 root 身份的。之后需要提供 intern01 的密码。

* sudo 命令不带 -u 选项，默认为切换到 root 用户身份，也即 `sudo fdisk` 等价于`sudo -u root fdisk`

## 5 管理用户组

### 5.1 添加用户组 *groupadd*

|选项|功能|
|:-:|:-:|
|-g|后面接一个数字，用来给用户组指定一个GID，该值必须唯一，不可相同，数值不可为负|
|-n|修改组的名称|
|-p|修改组的密码|
example:  
`groupadd [用户组名]` 创建新用户组  
`groupadd -g [GID] [用户组名]` 创建GID的新用户组

### 5.2 修改用户组设置 *groupmod*

|选项|功能|
|:-:|:-:|
|-g|后面接一个数字，修改组的GID|
|-r|建立一个系统虚拟用户组|

example:  
`groupmod -g [GID] -n [新用户组名] [原用户组名]` 修改用户组GID和用户组名

### 5.3 删除用户组 *groupdel*

example:  
`groupdel [用户组名]` 删除用户组

* 在删除用户组的时候请万分小心，因为这有可能涉及到其它和这个用户组相关的用户
* 你无法删除一个用户组，除非没有任何一个用户将这个用户作为主用户组（primary group），也即前面所提到的初始用户组（initial group）

## 6 用户/用户组相关配置文件

### 6.1 用户配置文件

#### 6.1.1 /etc/passwd文件

> 在 /etc/passwd 中，每一行都表示的是一个用户的信息；一行有 7 个字段；每个字段用:号分割。

example:

```text
intern01:x:500:500:张三:/home/intern01:/bin/bash
intern02:x:501:502::/home/intern02:/bin/bash
```

**第一字段**：用户名，在上面的例子中，我们看到这两个用户的用户名分别是intern01和intern02；  
**第二字段**：密码；在例子中我们看到的是一个x，其实密码已被映射到/etc/shadow文件中；  
**第三字段**：UID；  
**第四字段**：GID；  
**第五字段**：用户名全称，这是可选的，可以不设置，在intern01这个用户中，用户的全称是张三；而intern02这个用户没有全称；  
**第六字段**：用户的家目录所在位置；intern01这个用户是/home/intern01，而intern02这个用户是/home/intern02；  
**第七字段**：用户所用SHELL的类型，intern01和intern02都用的是bash；所以为/bin/bash。

#### 6.1.2 /etc/shadow 文件

> /etc/shadow文件是/etc/passwd的影子文件，这个文件并不由/etc/passwd而产生的，这两个文件是应该是对应互补的；shadow内容包括用户及被加密的密码以及其它/etc/passwd不能包括的信息，比如用户的有效期限等；这个文件只有root权限可以读取和操作。

example:

```text
intern01:$1$VE.Mq2Xf$2c9Qi7EQ9JP8GKF8gH7PB1:16662:0:99999:7:::
intern02:$1$IPDvUhXP$8R6J/VtPXvLyXxhLWPrnt/:16662:0:99999:7::16668:
```

**第一字段**：用户名（也被称之为登录名），在例子中有两条记录，也表示有两个用户intern01和intern02；  
**第二字段**：被加密的密码，如果有的用户在此字段中是x，表示这个用户不能登录系统，也可以看作是虚拟用户，不过虚拟用户和真实用户都是相对的，系统管理员随时可以对任何用户操作；  
**第三字段**：表示上次更改口令的天数（距1970年01月01日），上面的例子能说明intern01和intern02这两个用户，是在同一天更改了用户密码，当然是通过passwd命令来更改的，更改密码的时间距1970年01月01日的天数为16662；  
**第四字段**：禁用两次口令修改之间最小天数的功能，设置为0；  
**第五字段**：两次修改口令间隔最多的天数，在例子中都是99999天；这个值如果在添加用户时没有指定的话，是通过/etc/login.defs来获取默认值，PASS_MAX_DAYS 99999；你可以查看/etc/login.defs来查看，具体的值；  
**第六字段**：提前多少天警告用户口令将过期；当用户登录系统后，系统登录程序提醒用户口令将要作废；如果是系统默认值，是在添加用户时由/etc/login.defs文件定义中获取，在PASS_WARN_AGE中定义；在例子中的值是7 ，表示在用户口令将过期的前7天警告用户更改期口令；  
**第七字段**：在口令过期之后多少天禁用此用户；此字段表示用户口令作废多少天后，系统会禁用此用户，也就是说系统会不能再让此用户登录，也不会提示用户过期，是完全禁用；在例子中，此字段两个用户的都是空的，表示禁用这个功能；  
**第八字段**：用户过期日期；此字段指定了用户作废的天数（从1970年的1月1日开始的天数），如果这个字段的值为空，帐号永久可用；在例子中，我们看到intern01这个用户在此字段是空的，表示此用户永久可用；而intern02这个用户表示在距1970年01月01日后16668天后过期，算起来也就是2010年11月21号过期；  
**第九字段**：保留字段，目前为空，以备将来Linux发展之用。

### 6.2 用户组配置文件

#### 6.2.1 /etc/group 文件

> /etc/group文件是用户组的配置文件，内容包括用户和用户组，并且能显示出用户是归属哪个用户组或哪几个用户组，因为一个用户可以归属一个或多个不同的用户组；同一用户组的用户之间具有相似的特征。比如我们把某一用户加入到root用户组，那么这个用户就可以浏览root用户家目录的文件，如果root用户把某个文件的组读写执行权限开放，root用户组的所有用户都可以修改此文件，如果是可执行的文件（比如脚本），root用户组的用户也是可以执行的。

example:

```bash
root:x:0:root,intern02
# 用户组root，x是密码段，表示没有设置密码，GID是0，root用户组下包括root、intern02以及GID为0的其它用户（可以通过/etc/passwd查看）
intern01:x:500:intern02
# 用户组intern01，x是密码段，表示没有设置密码，GID是500，intern01用户组下包括intern02用户及GID为500的用户（可以通过/etc/passwd查看）
intern02:x:502:intern02
# 用户组intern02，x是密码段，表示没有设置密码，GID是502，intern02用户组下包括用户intern02及GID为502的用户（可以通过/etc/passwd查看）
helloer:x:503:
# 用户组helloer，x是密码段，表示没有设置密码，GID是503，helloer用户组下包括GID为503的用户（可以通过/etc/passwd查看）
```

**第一字段**：用户组名称；  
**第二字段**：用户组密码；  
**第三字段**：GID；  
**第四字段**：用户列表，每个用户之间用,号分割；本字段可以为空；如果字段为空表示用户组为GID的用户名。

#### 6.2.2 /etc/gshadow 文件

> /etc/gshadow是/etc/group的加密文件，比如用户组（Group）管理密码就是存放在这个文件。/etc/gshadow和/etc/group是互补的两个文件；对于大型服务器，针对很多用户和组，定制一些关系结构比较复杂的权限模型，设置用户组密码是极有必要的。比如我们不想让一些非用户组成员永久拥有用户组的权限和特性，这时我们可以通过密码验证的方式来让某些用户临时拥有一些用户组特性，这时就要用到用户组密码。

example:

```bash
intern01:!::intern02
intern02:oUS/q7NH75RhQ::intern02
```

**第一字段**：用户组名；  
**第二字段**：用户组的密码，intern01用户组无密码；intern02用户组有密码，已经加密；  
**第三字段**：用户组管理者，两者都为空；  
**第四字段**：intern01用户组所拥有的成员是intern02，然后还要对照一下/etc/group和/etc/passwd查看是否还有其它用户，一般默认添加的用户，有时同时也会创建用户组和用户名同名称；intern02用户组有成员intern02。

## 7 管理硬盘

### 7.1 查看硬盘 *fdisk*

example:  
`fdisk -l` 查看全部硬盘信息  
`fdisk -l /dev/sda` 查看硬盘信息  

```text
Disk /dev/sdb: 536.9 GB, 536870912000 bytes
255 heads, 63 sectors/track, 65270 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x2f7e945a
```

> 这个名为/dev/sdb的磁盘容量总共为536870912000字节（536.9GB），磁盘有255个磁头，每个磁道有63个扇区，总共有65270个柱面磁道。其中每个扇区容量为512 字节（这个磁盘的最小逻辑和物理单元，也是这个磁盘的读写的最小单元），因此每个柱面的容量为255×63×512字节8225280字节。

### 7.2 对硬盘进行分区 *fdisk*

`fdisk /dev/sdb`进入fdisk分区界面  
n：新建分区  
p：主分区 e：扩展分区 l：逻辑分区  
输入分区号  
起始柱面号，保持默认  
结束柱面号+100G（大小）  
w：将新分区写入分区表（之前按q退出fdisk，所有的操作都不会写入分区表）

|fdisk快捷键|功能|
|:-:|:-:|
|a|设置启动分区标识|
|d|删除一个分区|
|l|列出所有支持的分区类型的ID号|
|m|列出快捷键帮助|
|n|增加一个新的分区|
|p|列出分区表|
|q|退出不执行任务|
|t|改变一个分区类型|
|w|执行任务并退出|

`fdisk /dev/sdb`改动分区的System ID  
l：列出Linux默认支持的文件系统类型  
t：修改分区的System ID  
输入分区号  
输入分区类型代码  
w：写入分区表  

`fdisk /dev/sdb`删除分区  
d：删除分区  
输入要删除的分区号
> 在用 fdisk 对磁盘分区过程中，如果操作有误，可以按 q 键直接离开，所有之前的操作都不会写入磁盘的分区表，如果确认所有的操作无误，按w键将操作写入磁盘分区表。

### 7.3 格式化分区 *mkfs*

example:  
`mkfs -t [文件系统类型ext4] [/dev/sdb1]`  
`mkswap /dev/sdb7` 将sdb7分区格式化为交换分区swap

### 7.4 挂载分区 *mount*

|选项|功能|
|:-:|:-:|
|-t|与mkfs的选项非常类似的，可以加上文件系统种类来指定欲挂载的类型。常见的Linux支持类型有：ext2、ext3、ext4、vfat、reiserfs、iso9660（光盘格式）、nfs、cifs、smbfs（此三种为网络文件系统类型）|
|-L|系统除了利用设备名（例如/dev/hdc6）之外，还可以利用文件系统的标签（Label）来进行挂载|
|-l|单纯的输入mount会显示目前挂载的信息；加上-l可列出目前挂载的设备的标签|
|-a|依照配置文件/etc/fstab，将所有尚未挂载的设备都挂载上来|
|-o|后面可以接一些挂载时额外加上的参数|

|-o选项后接的额外参数|意义|
|:-:|:-:|
|ro, rw|挂载文件系统成为只读（ro）或可擦写（rw）|
|async, sync|此文件系统是否使用同步写入（sync）或异步（async）的内存机制，请参考文件系统运行方式。默认为async|
|auto, noauto|允许此分区被mount -a自动挂载（auto）|
|dev, nodev|是否允许此分区上可创建设备文件，dev为可允许|
|suid, nosuid|是否允许此分区含有suid/sgid的文件格式|
|exec, noexec|是否允许此分区拥有可运行二进制可执行文件|
|user, nouser|是否允许普通用户挂载此分区。一般来说，仅有root可以进行。|
|defaults|默认值为：rw, suid, dev, exec, auto, nouser, async|
|remount|重新挂载|

example:  
`mount [分区名] [挂载点]` 将指定分区挂载到目录树上的挂载点上  
`mount -t ext4 /dev/sdb1 /project/finished/`

> * -t ext4指明要挂载的分区的文件系统格式
> * -o：rw 可读可写；ro 只读；

`mount`不接参数：查看挂载好的分区

* 当挂载点文件夹中原本有文件，那么挂载分区后这些文件暂时不能访问，分区卸载后才能访问
* 尽量将分区挂载到空目录上；不要将同一个分区挂载到不同目录上

#### 开机自动挂载分区

/etc/fstab  
[要挂载的设备]/dev/sdb1  [挂载点]  [分区文件系统类型]  [挂载参数]  [Dump参数（需要dump每天备份则写1，否则写0，不定期备份写2）]  [开机是否检查分区次序（0为不需要，1为优先，2为次优先）]  
或LABEL=某个设备标签  
UUID=某个设备UUID  
`/dev/sdb1  /project/finished   ext4   defaults  0  0`

### 7.5 显示所有文件系统i节点和磁盘块的使用情况 *df*

|选项|功能|
|:-:|:-:|
|-a|显示所有挂载的文件系统的磁盘使用情况（包括虚拟的不占用硬盘空间的文件系统，如/proc文件系统）|
|-k|以k字节为单位显示|
|-i|显示inode信息，而不是块|
|-t|显示各指定类型的文件系统的磁盘空间使用情况|
|-x|列出不是某一指定类型文件系统的磁盘空间使用情况（与-t选项相反）|
|-T|显示文件系统类型|

### 7.6 卸载分区 *umount*

|选项|功能|
|:-:|:-:|
|-f|强制卸载|
example:  
`umount [分区名或挂载点]` 卸载分区

### 7.7 分区配置文件 */etc/fstab*

|序号|字段名|解释|
|:-:|:-:|:-:|
|字段1|设备名/UUID/设备标签|etc/fstab文件的第一个字段指定了要挂载的设备，可以是一个/dev目录下的设备文件，例如/dev/sdb1或者/dev/cdrom之类的。也可以通过设备标签或者所谓的UUID来指定要挂载的设备如LABEL=pa_disk或者UUID=3e6be9de-8139-11d1-9106-a43f08d823a6。用设备标签或者设备的UUID来指定要挂载的设备更加安全和稳定。|
|字段2|挂载点|指定了挂载设备的目录，对于swap，挂载点为none；对于挂载目录包含空格的情况，用"\040"来表示空格|
|字段3|挂载分区文件系统类型|定义了该设备上的文件系统，一般常见的文件类型为ext2、ext3、ext4（Linux设备的常用文件类型）、或者iso9600（光盘文件系统类型）等。如果这个字段定义为swap，这条纪录将关联到一个用于交换目的的文件或分区。如果这个字段定义为ignored，这行将被忽略。这对于显示目前没有使用的分区非常有用。|
|字段4|挂载参数|指定加载该设备的文件系统是需要使用的特定参数选项，多个参数是由逗号分隔开来。|
|字段5|Dump参数|该选项被"dump"命令使用来检查一个文件系统是否应该进行dump备份，若不需要就设置该字段为0，如果需要每天备份的，这个字段就应该为1，如果需要不定期备份的的，这个字段就应该为2。|
|字段6|启动检查分区的次序|该字段被fsck命令所使用来确定进行在系统重启进行文件系统检查时的顺序，对于根分区"/"这个值应设为1，其它文件系统可以设为2，在同一个物理硬盘内的文件系统应该被顺序检测，而不同硬盘中的文件系统则应该同时检测以充分利用系统的并行性。如果最后一个字段值为0或没有设置， fsck程序装跳过此文件系统的检测。|

### 7.8 为分区设置标签 *e2label*

> e2label 可以给分区加上标签（label），然后就可以使用标签来挂载/卸载该分区。这对于有很多磁盘的系统，并且磁盘次序可能会发生变化的情况，会很有帮助。假设主机上有若干块可以热插拔的硬盘，在主机运行过程中，这些硬盘需要经常插拔，因此硬盘的次序包括硬盘的设备名会经常改变（如/etc/sdb在下次可能会变成/etc/sdd）。这时就可以用e2label给分区设置一个标签名，在/etc/fstab中利用标签而不是设备名来自动挂载分区。

example:  
`e2label [分区设备名]` 查看分区标签  
`e2label [分区设备名] [标签名]` 为分区设置标签

* 新设定的标签名称不能超过16字符

### 7.9 显示系统中所有存储设备的UUID *blkid*

example:  
`blkid`列出系统中所有存储设备的UUID

## 8 管理网络

### 8.1 配置/显示系统网络接口 *ifconfig*

|选项|功能|
|:-:|:-:|
|无参数|显示当前所有有效接口的状态|
|单个接口名|显示给出的那个接口的状态|
|-a|显示所有接口的状态，包括那些停用的接口|
|up|此选项激活接口|
|down|此选项使接口关闭|
|[-]arp|允许或禁止在接口上使用ARP协议|
|[-]allmulti|允许或禁止组播模式（all-multicast）。如果选用，则接口可以接收网络上的所有组播分组|
|metric N|将接口度量值设置为整数N。（译注：度量值表示在这个路径上发送一个分组的成本，就是通过多少个路由）|
|mtu N|此选项设定接口的最大传输单元MTU|
|netmask [子网掩码]|为接口设定IP网络掩码。缺省值通常是A、B或C类的网络掩码（由接口的 IP 地址推出），但也可设为其它值。|
|[-]broadcast [广播地址]|如果给出了地址参数，则可以为接口设定该协议的广播地址。否则，为接口设置（或清除）IFF_BROADCAST标志。|
|IP地址|为接口分配的IP地址|

example:  
`ifconfig` 查看已经开启的网络接口  

```bash
eth0 Link encap:Ethernet HWaddr 00:0C:29:47:B0:C7
     inet addr:192.168.71.128 Bcast:192.168.71.255 Mask:255.255.255.0
     UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
     RX packets:9776 errors:0 dropped:0 overruns:0 frame:0
     TX packets:3245 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:1000
     RX bytes:919008 (897.4 KiB) TX bytes:635590 (620.6 KiB)
# link encap表示网络连接的类型，Ethernet是以太网
# HWaddr是网络接口的硬件地址
# Inet addr是网络接口的ip地址，Bcast是网络的广播地址，Mask是子网掩码
# UP BROADCAST RUNNING MULTICAST表示网络接口的运行状态
# RX和TX是网络接口收发包的情况
# conllisions表示以太网发生冲突的次数，如果该值过高，就要考虑网络硬件连接处可能发生了问题
lo Link encap:Local Loopback
   inet addr:127.0.0.1 Mask:255.0.0.0
   inet6 addr: ::1/128 Scope:Host
   UP LOOPBACK RUNNING MTU:16436 Metric:1
   RX packets:1590 errors:0 dropped:0 overruns:0 frame:0
   TX packets:1590 errors:0 dropped:0 overruns:0 carrier:0
   collisions:0 txqueuelen:0
   RX bytes:1884308 (1.7 MiB) TX bytes:1884308 (1.7 MiB)
# lo不是一个真正的网络接口，是一个特殊的模拟出来的网络接口，每个系统都有它，叫回环接口（loop），其ip永远为127.0.0.1，子网掩码为255.0.0.0。回环接口为系统提供一个单机网络环境，一般用于网络程序的调试，许多程序的运行也需要这个接口。
```

`ifconfig [接口名]` 查看特定网络接口  
`ifconfig -a` 查看主机中所有网络接口  
> 如果网络接口因为其他原因没有启动，那么就只能够看到回环接口lo的相关状态。你可以用 `ifconfig -a` 查看到所有安装好的网络接口（无论接口有没有被启动和配置好），此时可能情况有三种：
>
> * 情况1：仍然没有看到接口，那么就说明网卡硬件连接或者驱动出现问题，导致系统无法识别此网卡了，此时应该检查硬件或者重新安装驱动，如果仍然无法识别，那么就需要考虑更换网卡。
> * 情况2：看到接口了，但是输出中没有Inet addr、Bcast、Mask等参数出现 ，那就表示网卡硬件没有问题，是接口没有配置好，此时就应该查看并编辑相关配置文件对接口进行配置。
> * 情况3：看到接口了，并且接口一切正常，那么就可能是接口未开启，可以使用ifconfig命令来开启接口。

`ifconfig eth1 up` 开启eth1网络接口  
`ifconfig eth1 down` 关闭eth1网络接口  
`ifconfig eth1 [IP地址] netmask [子网掩码]` 配置eth1的IP地址  
`ifconfig eth1 mtu 5000` 修改eth1的mtu值  

* 用ifconfig修改的网络参数只是临时的，不会永久保存

### 8.2 网络配置文件

系统中重要的有关网络配置文件为：

* /etc/services
* /etc/host.conf
* /etc/nsswitch.conf
* /etc/xinetd.conf
* /etc/modules.conf
* /etc/sysconfig/network
* /etc/hosts
* /etc/resolv.conf
* /etc/sysconfig/network-scripts/ifcfg-ethN

#### 8.2.1 /etc/sysconfig/network 文件

用来为主机设定全局网络参数（也即不是针对单个网络接口的参数）。
|参数名|参数值|
|:-:|:-:|
|NETWORKING=\<value>|\<value>值表示是否配置这个网络可以是如下值：yes-配置网络；no-不配置网络|
|HOSTNAME=\<value>|\<value>值为主机名，一般来说，这个主机名应该是一个完整的FQDN（Fully Qualified Domain Name），也即主机名+域名，如hostname.expample.com。但是主机名并非必须为FQDN，你可以给主机取一个任意格式的名字|
|GATEWAY=\<value>|\<value>值为网络的默认网关IP地址|

* /etc/sysconfig/network中的GATEWAY参数会被/etc/sysconfig/network-scripts/ifcfg-eth0中的GATEWAY参数覆盖。

#### 8.2.2 /etc/sysconfig/network-scripts/ifcfg-ethN 文件

对于主机上的每个网络接口都需要进行配置，在Linux中每个网络接口都有一个独立的配置文件，文件名一般为/etc/sysconfig/network-scripts/ifcfg-ethN，其中N是一个数字，代表主机网络接口的序号。

|参数名|参数值|
|:-:|:-:|
|BOOTPROTO=\<value>|\<value>值表示采用何种方式来配置主机网络参数，可以是如下值："none/static"-手动配置此主机网络；"bootp"-使用BOOTP协议动态配置主机网络参数；"dhcp"-用dhcp协议动态配置主机网络参数|
|DEVICE=\<value>|\<value>值表示物理设备的名称，也即网卡的名称|
|DEFROUTE=\<value>|\<value>值表示是否将本网络接口作为网络的默认路由（default route）可以是如下值："yes"-是；"no"-否|
|DNS{1,2}=\<value>|\<value>值表示DNS服务器的IP地址，可以添加两个DNS服务器DNS1和DNS2，如果PEERDNS参数值为yes，那么此DNS参数值将覆盖/etc/resolv.conf文件中的DNS服务器配置|
|HWADDR=\<value>|\<value>值为太网卡的MAC地址，是如下格式一个12位的16进制串AA:BB:CC:DD:EE:FF。如果主机上有两张以上的网卡这个参数就是必须的，可以保证不管网卡加载次序如何，设备名都不会改变，进而能够让正确的配置文件来对其进行配置|
|IPADDR=\<value>|\<value>值为当前网络接口IP地址|
|IPV4_FAILURE_FATAL=\<value>|\<value>值指的是当IPv4和IPv6配置都可用 时，IPv4配置失败时是否视为设备激活失败。可以是如下值："yes"-是；"no"-否|
|IPV6INIT=\<value>|\<value>值表示是否配置主机的IPv6网络参数，可以是如下值："yes"-是；"no"-否|
|NETMASK=\<value>|\<value>值为当前网络接口的子网掩码|
|NM_CONTROLLED=\<value>|\<value>值表示此网络接口是否允许RHEL和CentOS 中的默认图形界面的网络配置工具NetworkManager来进行配置。可以是如下值："yes"-是；"no"-否|
|ONBOOT=\<value>|\<value>值表示是否在启动时激活此网络接口，可以是如下值："yes"-是；"no"-否|
|PEERDNS=\<value>|\<value>值表示是否允许接口配置文件中的DNS参数值覆盖/etc/resolv.conf文件中的DNS服务器配置，可以是如下值："yes"-是；"no"-否|
|PEERROUTES=\<value>||
|SRCADDR=\<value>|表示为从这个接口发出去的数据包指定另外一个源地址\<value>（而不是接口的IP地址）|
|USERCTL=\<value>|\<value>值表示是否允许除root用户之外的用户配置此网络接口，可以是如下值："yes"-是；"no"-否|

#### 8.2.3 /etc/resolv.conf 和 /etc/hosts 文件

该文件是DNS客户端配置文件，它的格式很简单，每行以一个关键字开头，后接配置参数。最主要是nameserver关键字，如果没指定nameserver就找不到DNS服务器，其它关键字都是可选的。

|参数名|参数值|
|:-:|:-:|
|nameserver=\<value>|\<value>为DNS服务器的IP地址，总共可以指定3个DNS服务器IP地址|
|domain=\<value>|\<value>值表示本地域名|
|search=\<value>|\<value>值表示域名的搜索列表，默认情况下仅包括本地域名|

> * /etc/hosts 文件是一个用于储存计算机网络中各节点信息的文件。这个文件负责将主机名映射到相应的IP地址。hosts文件通常用于补充或取代小型网络中DNS的功能。和DNS不同的是，用户可以直接对/hosts文件进行控制。
> * 在默认情况下，/etc/hosts 仅包括两行，分别用于指定 IPv4 网络中和 IPv6 网络中回环接口的主机名（默认情况下为localhost.localdomain）

### 8.3 修改主机名

/etc/sysconfig/network  
HOSTNAME=指定主机名  
/etc/hosts  
在文件末尾添加一行：本机IP地址和本机主机名  
service network restart  
重启系统

### 8.4 配置TCP/IP网络参数

`cd /etc/sysconfig/network-scripts/` 目录下，文件名为 ifcfg-ethN  
BOOTPROTO=static  
IPADDR=主机IP地址  
GATEWAT=默认网关（一个主机只有一个默认网关，多张网卡只需配置一次）  
NETMASK=子网掩码  
DNS1=指定DNS服务器IP地址  
`service network restart` 重启网络使设置生效

如果重新用DHCP自动配置网络  
BOOTPROTO=DHCP  
下面四行进行注释  
`service network restart` 重启网络使设置生效

### 8.5 检查DNS服务器是否连接上

`dig [域名]` 检查DNS服务器是否连接上  
出现ANSWER SECTION和SERVER两行，表示DNS设置正确

### 8.6 检查网络连接 *ping*

example:  
`ping -c [数据包个数（ping的次数）] [主机名或主机IP或主机网关]`

## 9 软件管理

### 9.1 RPM包管理器 *RPM*

|选项|功能|
|:-:|:-:|
|-i [安装包文件名]|安装软件|
|-v|显示安装详细信息（与i连用）|
|-h|安装时输出（#）作为进度条（与iv连用）|
|-e [软件包名]|卸载软件|
|--replacepkg|无论软件包是否已被安装，都强行安装|
|--test|安装测试，并不实际安装|
|--nodeps|忽略软件包的依赖关系强行安装|
|--force|忽略软件包及文件的冲突|
|-q [软件包名]|查询软件包|
|-a|列出所有软件包（与q连用）|
|-p [安装包文件名]|列出安装后的软件包名（与q连用）|

<https://www.rpmfind.net>

example:  
`rpm -q opera` 查询名为Opera的软件包是否安装  
`rpm -ivh [软件包名]` 安装（i）软件包，显示安装详细信息（v），输出#作为进度条（h）  
`rpm -e [软件包全名]` 卸载软件包

* 有时需要先安装依赖的软件包再安装目标软件包

### 9.2 从网站上下载文件 *wget*

example:  
`wget [链接]` 下载链接中的文件到当前工作目录中  

下载并安装yum示例：

```bash
# 下载
wget http://mirrors.163.com/centos/6.3/os/x86_64/Packages/yum-3.2.29-30.el6.centos.noarch.rpm
wget http://mirrors.163.com/centos/6.3/os/x86_64/Packages/yum-metadata-parser-1.1.2-16.el6.x86_64.rpm
wget http://mirrors.163.com/centos/6.3/os/x86_64/Packages/yum-utils-1.1.30-14.el6.noarch.rpm
wget http://mirrors.163.com/centos/6.3/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.30-14.el6.noarch.rpm
# 用RPM安装
rpm -ivh python-iniparse-0.3.1-2.1.el6.noarch.rpm
rpm -ivh yum-metadata-parser-1.1.2-16.el6.x86_64.rpm
rpm -ivh yum-3.2.29-30.el6.centos.noarch.rpm yum-plugin-fastestmirror-1.1.30-14.el6.noarch.rpm
# 这两个软件包必须同时安装，否则会发生互依赖性问题
rpm -ivh yum-utils-1.1.30-14.el6.noarch.rpm
```

### 9.3 安装包管理器 *yum*

安装完YUM后进行测试：

```bash
yum clean all # 清除yum所有软件包缓存信息
yum makecache # 将服务器上的软件包信息缓存到本地，以提高搜索安装软件的速度
yum install finger # 安装一个名为"finger"的命令，测试yum是否可用
```

> 当第一次使用yum或yum源有更新时，yum会自动下载所有所需的headers放置于/var/cache/yum目录下，所需时间可能较长。

|yum命令|功能|
|:-:|:-:|
|yum clean all|清除缓存中旧的rpm头文件和包文件|
|yum makecache|建立新的缓存|
|yum list|列出所有升级源上的包|
|yum list available|列出资源库中所有可以安装或更新的rpm包|
|yum list updates|列出所有升级源上的可以更新包|
|yum list installed|列出已经安装的包|
|yum search <关键字>|搜索匹配特定字符的rpm包|
|yum info <软件包名>|列出资源库中特定的可以安装或更新以及已经安装的 rpm包的信息|
|yum install <软件包名>|安装rpm包|
|yum update <软件包名>|更新rpm包|
|yum remove <软件包名>|卸载rpm包|

example:  
`yum clean all` 首先清除yum原有的软件包缓存数据  
`yum makecache` 将当前服务器上的软件包相关信息存到本地以提高搜索软件的速度  
`yum install gcc-c++` 安装c++编译器  
`yum list [软件包名]` 查询软件包是否安装（软件包名支持通配符）  
`yum list installed` 列出主机中已经安装的软件包  
`yum list available` 列出当前软件源中所有可安装的软件包  
`yum list installed|less` 用管道结合less命令查看  
`yum info [软件包名]` 查看软件包的具体信息  
`yum update [软件包名]` 更新软件包  
`yum remove [软件包名]` 卸载软件包

### 9.4 为yum配置第三方软件源（具体百度）

第一步：登录源官网用wget命令下载源的rpm包  
第二步：用rpm命令安装rpm包  
注：cd /etc/yum.repos.d文件夹下保存各软件源的配置文件  
第三步：`yum install yum-plugin-priorities` 安装软件源优先级排序插件  
第四步：`vim /etc/yum.repos.d/CentOS-Base.repo` 打开官方源配置文件  
第五步：在每个中括号的末尾添加priority=1（[base] [updates] [extras] [centosplus] [contrib]）  
第六步：`vim /etc/yum.repos.d/rpmforge.repo` 打开RepoForge源配置文件  
第七步：在软件仓库末尾加上priority=10（次于官方源）

## 10 管理进程

进程分类：

* 交互进程：由一个shell启动的进程。交互进程既可以在前台运行，也可以在后台运行。
* 批处理进程：这种进程和终端没有联系，是一个进程序列。
* 守护进程：Linux系统启动时启动的进程，并在后台运行。

进程的描述：

|字段|含义|
|:-:|:-:|
|USER|启动进程用户|
|PID|进程标志号|
|PPID|父进程的ID，父子进程的关系是管理和被管理的关系，当父进程终止时，子进程也随之而终止。但子进程终止，父进程并不一定终止。|
|%CPU|运行该进程占用CPU的时间与该进程总的运行时间的比例|
|%MEM|该进程占用内存和总内存的比例|
|VSZ|占用的虚拟内存大小|
|RSS|进程占用的物理内存值|
|TTY|进程建立时所对应的终端，“?”表示该进程不占用终端|
|STAT|进程的状态，状态分为：D不可中断的睡眠；R就绪（在可运行队列中）；S睡眠；T被跟踪或停止；Z终止（僵死）的进程；W没有足够的内存分页可分配；<高优先序的进程；N低优先序的进程；L有内存分页分配并锁在内存体内（实时系统或I/O）；+位于后台的进程；s进程的领导者（在它之下有子进程）。|
|START|为进程开始时间|
|TIME|为执行的时间|
|COMMAND|是对应的命令名|

### 10.1 查看进程 *ps*

|选项|功能|
|:-:|:-:|
|l|长格式输出|
|u|按用户名和启动时间的顺序来显示进程|
|j|用任务格式来显示进程|
|f|用树形格式来显示进程|
|a|显示所有用户的所有进程（包括其它用户）|
|x|显示无控制终端的进程|
|r|显示运行中的进程|
|--sort <+/-><字段名>|按指定字段对ps输出进行排序，+表示升序，-表示降序，“+”字符是可选的，因为默认按升序排列|

* 注：ps的选项是不带连字符“-”的。

example:  
`ps -A` 列出系统中所有进程  
> PID：进程ID；TTY：进程所使用的终端（？表示不使用终端）；TIME：进程运行时间；CMD：进程对应的程序名

`ps -Af` 列出进程更加完整的信息  
> UID：进程是由哪个用户运行的；PPID：进程父进程的PID；C：进程占用CPU的比例；STIME：进程开始运行的时间

`ps -Af|grep sshd` 查找名称中带有sshd字样的进程  
`ps -Af|less` 分页查看ps输出  
`ps -Al` 列出完整的进程信息  
> F：进程的旗标；S：进程的运行状态；PRI：进程优先级；NI：进程的Nice值；ADDR：进程的内存地址；SZ：进程占用内存大小；WCHAN：表示进程是否正在运行当中；

### 10.2 动态监视系统进程 *top*

|选项|功能|
|:-:|:-:|
|-d|指定更新的间隔，以秒为单位|
|-q|没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行|
|-c|显示进程完整的路径与名称|

|交互快捷键|功能|
|:-:|:-:|
|space|立即更新|
|>|向下翻页|
|<|向上翻页|
|T|按进程运行时间进行降序排序|
|M|按内存占用情况进行降序排序|
|N|以进程ID进行降序排序|
|P|按CPU占用情况降序排序（默认）|
|R|反向排序|
|k|结束指定进程|
|q|退出top|

example:  
`top` 动态查看进程信息  
> PID：进程ID；USER：进程发起者；PR：进程优先级；NI：Nice值；VIRT：使用虚拟内存总量（KB）；RES：进程使用的，未被换出的物理内存大小；SHR：共享内存大小；S：进程运行状态；%CPU：上次更新到现在CPU时间占用百分比；%MEM：进程使用的物理内存百分比；TIME+：进程使用CPU的总计时间；COMMAND：产生进程的命令名称

### 10.3 结束进程 *kill*

|选项|功能|
|:-:|:-:|
|-signal|表示向进程发出的信号，如果没有指定任何信号，默认发送的信号为SIGTERM（-15），可将指定进程终止。若仍无法终止该进程，可使用更强力的SIGKILL（-9）信号尝试强制终止进程|

example:  
`kill -l` 列出kill命令能发送的所有信号  
`kill [进程PID]` 结束进程  
`kill -9 [进程PID]` 将序号为9的信号发送给进程（强制结束进程）（慎用）

* 只有根用户和进程发起者可以使用kill命令

`pkill [程序名]` 根据程序名结束进程  
`pkill -u [用户名]` 结束由“用户名”发起的所有进程  
`xkill` 左键单击要结束的进程窗口

### 10.4 显示网络连接、路由表、接口统计数据、伪连接及多播成员相关信息 *netstat*

|选项|功能|
|:-:|:-:|
|-r|显示路由表|
|-I|显示网络接口的连接情况（可以加上eth0、lo等参数）|
|-s|显示IP、ICMP、IcmpMsg、TCP、UDP、UdpLite、TcpExt、IpExt的统计信息|
|-n|以数字形式显示地址和端口号|
|-p|显示PID/Program name|
|-l|显示监听端口|
|-a|显示所有连接和监听端口|
|-t|显示TCP传输协议的连线状况|
|-u|显示UDP传输协议的连线状况|
|-e|显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。（这个选项可以用来统计一些基本的网络流量）|

example:  
`netstat -a` 输出所有网络连接

|字段名|字段意义|
|:-:|:-:|
|Proto|连接使用的协议，主要就是TCP和UDP两种|
|Recv-Q|尚未接收的字节数|
|Send-Q|尚未发送到目标的字节数|
|Local Address|本地或源的地址和端口，可以是“主机IP:端口号”（使用-n选项时），也可以是“完整的主机名:端口名称”。其中如果IP地址为“0.0.0.0”或者主机名为“*”就表示在所有链接的相应端口，如“0.0.0.0:22”就表示在本机所有链接的22端口上都进行监听。|
|Foreign Address|目标地址和端口|
|State|当前socket连接的状态（下面7种）|

* ESTABLISHED：连接已建立
* SYN_SENT：正在尝试建立连接（发出SYN标志）
* SYN_RECV：接收到一个连接建立请求
* FIN_WAIT1：socket关闭，连接中断中
* FIN_WAIT2：连接已中断，但socket正在等待对方回应
* TIME_WAIT：连接已中断，socket仍在等待，以处理仍然存在在网络中的包
* LISTEN：已建立监听，socket正在监听端口输入，但尚未建立连接

`netstat -ltp` 查看在监听中的TCP网络连接
> -l选项表示显示正在监听的连接（不显示已经建立的连接），-t选项表示只显示TCP连接，-p选项表示显示连接从属的的进程PID和进程名称。

## 11 管理系统服务

### 11.1 操纵系统服务 *service*

|命令|功能|
|:-:|:-:|
|service [服务脚本名]|打印指定服务的命令行使用帮助|
|service [服务脚本名] start|启动指定的系统服务|
|service [服务脚本名] status|查看指定的系统服务状态|
|service [服务脚本名] stop |停止指定的系统服务|
|service [服务脚本名] restart|重新启动指定的系统服务，即先停止然后再启动|

### 11.2 配置服务运行级别 *chkconfig*

|级别|目的|
|:-:|:-:|
|0|关闭（或停止）系统|
|1|单用户模式|
|2|没有联网的多用户模式|
|3|联网的多用户模式|
|4|保留暂未使用|
|5|联网并且使用图形界面的多用户模式|
|6|重启系统|

example:  
`chkconfig --list` 显示系统服务列表  
`chkconfig --list|grep httpd` 查询系统服务  
`chkconfig --level 35 httpd on` 设置运行级别3和5为开启（设置httpd服务开机自启动）

### 11.3 管理系统服务 *systemctl*

systemctl整合了service与chkconfig功能于一体。

|命令|功能|
|:-:|:-:|
|systemctl is-enabled [服务名].service|查询服务是否开机启动|
|systemctl enable [服务名].service|开机运行服务|
|systemctl disable [服务名].service|取消开机运行|
|systemctl start [服务名].service|启动服务|
|systemctl stop [服务名].service|停止服务|
|systemctl restart [服务名].service|重启服务|
|systemctl reload [服务名].service|重新加载服务配置文件|
|systemctl status [服务名].service|查询服务运行状态|
|systemctl --failed|显示启动失败的服务|
